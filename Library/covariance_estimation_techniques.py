# -*- coding: utf-8 -*-
"""Covariance_estimation_techniques

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-Cemk4T2otCygATAwqHCo02IXyJtRlvc
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from scipy.linalg import svd, eigh
from numpy.linalg import inv, LinAlgError

# Covariance Matrix
def generate_covariance_matrix(correlation_matrix, variance_vector):
    return np.array(np.outer(np.sqrt(variance_vector), np.sqrt(variance_vector)) * correlation_matrix)

# Exponentially Weighted Covariance Matrix
def exp_weighted_cov(data, lambda_value=0.97):
  # Initialize the covariance matrix with zeros
  ewcov = np.zeros((len(data.columns), len(data.columns)))

  # Loop through each asset
  for i in range(len(data.columns)):
      for j in range(i, len(data.columns)):
          # Calculate the weights
          weights = [(1 - lambda_value) * (lambda_value ** (k - 1)) for k in range(1, len(data) + 1)]
          weights = np.array(weights) / np.sum(weights)
          weights = sorted(weights)
          
          # Calculate the mean of each asset
          mean_i = data.iloc[:, i].mean()
          mean_j = data.iloc[:, j].mean()
          
          # Calculate the weighted covariance
          ewcov[i][j] = (weights * ((data.iloc[:, i] - mean_i) * (data.iloc[:, j] - mean_j))).sum()
          ewcov[j][i] = ewcov[i][j]

  return ewcov

# Cholesky Factorization
def chol_psd(A):
  n = A.shape[1]
  root = np.zeros((n,n))
  
  # loop over columns
  for i in range(n):
    s = 0.0
    if i > 0:
      s = root[i][:i].T @ root[i][:i]
    
    # Diagonal Element
    temp = A[i][i] - s
    if temp <= 0 and temp >= -1e-8:
      temp = 0.0
    root[i][i] = np.sqrt(temp)

    # check for the 0 eign value. set the column to 0 if we have one
    if root[i][i] == 0.0:
      root[i][(i+1):n] = 0.0
    else:
      # update off diagonal rows of the column
      ir = 1.0/root[i][i]
      for j in np.arange(i+1,n):
        s = root[j][:i].T @ root[i][:i]
        root[j][i] = (A[j][i] -s) * ir
  return root

