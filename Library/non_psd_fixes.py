# -*- coding: utf-8 -*-
"""Non_PSD_fixes

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XBzTTe612nRk0d8ZgLXolO7A_jjYZGIT
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from scipy.linalg import svd, eigh
from numpy.linalg import inv, LinAlgError

#non_psd -> near_psd
def near_psd(a, epsilon=0.0):
  n = a.shape[0]


  invSD = None
  out = a.copy()

  #calculate the correlation matrix if we got a covariance
  if (np.count_nonzero(np.diag(out) == 1.0) != n):
      invSD = np.diag(1.0 / np.sqrt(np.diag(out)))
      out = np.dot(np.dot(invSD, out), invSD)

  #SVD, update the eigen value and scale
  vals, vecs = np.linalg.eigh(out)
  vals = np.maximum(vals, epsilon)
  T = 1.0 / (np.dot(np.dot(vecs, np.diag(vals)), vecs.T))
  T = np.diag(np.sqrt(np.diag(T)))
  l = np.diag(np.sqrt(vals))
  B = np.dot(np.dot(T, vecs), l)
  out = np.dot(B, B.T)

  #Add back the variance
  if invSD is not None:
      invSD = np.diag(1.0 / np.diag(invSD))
      out = np.dot(np.dot(invSD, out), invSD)
  return out

#non_psd -> near_psd_Higham
def Higham(A, num_iter):
  while num_iter > 0:
    eigvals, eigvecs = eigh(A)
    neg = 0
    for e in eigvals:
      if e < 0:
        #n = A.shape[0]
        D = np.diag(np.maximum(eigvals, 0))
        V = eigvecs @ np.sqrt(D)
        A = V @ V.T
        neg+=1
        break
    if neg == 0:
      break
    num_iter -= 1

  return (A + A.T) / 2

